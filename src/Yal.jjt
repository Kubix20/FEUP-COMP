options {
  LOOKAHEAD=1;
  MULTI=true;
  IGNORE_CASE=true;
  NODE_DEFAULT_VOID=true;
  TRACK_TOKENS=true;
}

PARSER_BEGIN(Yal)
import java.io.FileReader;
import java.io.FileNotFoundException;
public class Yal {
  public static int nErrors = 0;
  public static final int ERROR_LIMIT = 5;
  public static void main(String args[]) throws ParseException, FileNotFoundException {
	String newline = System.lineSeparator();
	System.out.println(newline+newline+
					   "<<<<<<<< Parsing file "+ args[0]+ " >>>>>>>>>"+
					   newline+newline);
    Yal parser = new Yal(new FileReader(args[0]));
    ASTModule root = parser.Module();
    root.dump(">");
    System.out.println("Program parsed with "+Yal.nErrors+" errors");
  }
}
PARSER_END(Yal)

<DEFAULT> SKIP : {
  " "
  | "\t"
  | "\n"
  | "\r"
  | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
  | <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}
/* reserved words */
<DEFAULT> TOKEN : {
  <RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
  | <ADDSUB_OP: "+" | "-">
  | <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
  | <BITWISE_OP: "&" | "|" | "^">
  | <NOT_OP: "!">
  | <WHILE: "while">
  | <IF: "if">
  | <ELSE: "else">
  | <ASSIGN: "=">
  | <ASPA: "\"">
  | <LPAR: "(">
  | <RPAR: ")">
  | <VIRG: ",">
  | <PVIRG: ";">
  | <LCHAVETA: "{">
  | <RCHAVETA: "}">
  | <FUNCTION: "function">
  | <MODULE: "module">
  | <SIZE: "size">
}
<DEFAULT> TOKEN : {
  <INTEGER: (<DIGIT>)+>
  | <ID: <LETTER> (<LETTER> | <DIGIT>)*>
  | <#LETTER: ["$","A"-"Z","_","a"-"z"]>
  | <#DIGIT: ["0"-"9"]>
  | <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

JAVACODE
void error_skipto(ParseException e, int kind, String whereWasCaught) {
  ++Yal.nErrors;
  System.out.println("EXCEPTION CAUGHT IN "+whereWasCaught+": "+e.toString());  // print the error message
  Token t;
  //MUST be do while
  do {
    t = getNextToken();
	System.out.println(t);
  } while (t.kind != kind);
  System.out.println("Proceeding with "+t.image+" of kind "+t.kind);
}

JAVACODE
boolean contains(int[] kinds, int kind) {
  for(int i=0; i<kinds.length; i++) {
	  if(kinds[i] == kind)
		  return true;
  }
  return false;
}
JAVACODE
void error_multskipto(ParseException e, int[] kinds, String whereWasCaught) {
  ++Yal.nErrors;
  System.out.println("EXCEPTION CAUGHT IN "+whereWasCaught+": "+e.toString());  // print the error message
  Token t;
  //MUST be do while
  do {
    t = getNextToken();
	System.out.println(t);
  } while (!contains(kinds,t.kind));
  System.out.println("Proceeding with "+t.image+" of kind "+t.kind);
}

JAVACODE
void error(ParseException e, String whereWasCaught) {
  ++Yal.nErrors;
  System.out.println("EXCEPTION CAUGHT IN "+whereWasCaught+": "+e.toString());  // print the error message
}

ASTModule Module() #Module : {Token t1;}
{
  <MODULE> t1=<ID>{jjtThis.setValues(t1.image);} <LCHAVETA> (Declaration())* (Function())*
  try {
	<RCHAVETA>
  }
  catch(ParseException e){
    error_skipto(e, RCHAVETA, "BEFORE MODULE END");
  }
  {return jjtThis;}
}

void Declaration() #Declaration : {Token t1;}
{
  Element() [<ASSIGN> (("[" ArraySize() "]") | [<ADDSUB_OP>] t1=<INTEGER>{jjtThis.setValues(t1.image);})] <PVIRG>
}

void Function() #Function : {Token t1;}
{
  try {
      <FUNCTION> [LOOKAHEAD(2) Element() <ASSIGN>] t1=<ID>{jjtThis.setValues(t1.image);} <LPAR>
  }
  catch(ParseException e){
    error_skipto(e, LPAR, "FUNCTION DECLARATION");
  }

  try {
    [Varlist()] <RPAR>
  }
  catch(ParseException e){
    error_skipto(e, RPAR, "FUNCTION DECLARATION ARGS");
  }

    <LCHAVETA> Stmtlst() <RCHAVETA>
}

void Varlist() : {}
{
  (Element()) (<VIRG> (Element()))*
}

void Element() #Element : {Token t1;}
{
  t1=<ID>{jjtThis.setValues(t1.image);} ["[" "]"]
}

void Stmtlst() : {}
{
  (Stmt())*
}

void Stmt() : {}
{

  try{
	While() | If() | LOOKAHEAD(3) Assign() | Call() <PVIRG>
  }
  catch(ParseException e){
	  int[] kinds = {PVIRG, RPAR};
     error_multskipto(e, kinds, "STATEMENT CALL");
  }
}

void Assign() #Assign : {}
{
	Lhs() <ASSIGN>
    try{
      Rhs() <PVIRG>
	}
	catch(ParseException e){
      error_skipto(e, PVIRG, "RIGHT ASSIGN");
    }
}

void Lhs() : {}
{
  Access()
}

void Rhs() #Rhs : {Token t1;}
{
  (Term() [( t1=<ARITH_OP> | t1=<BITWISE_OP> | t1=<ADDSUB_OP> )
  {jjtThis.setValues(t1.image);}
   Term()])  | "[" ArraySize() "]"
}

void ArraySize() #ArraySize : {Token t1;}
{
  Access() | t1=<INTEGER>{jjtThis.setValues(t1.image);}
}

void Term() #Term : {Token t1=null, t2=null;}
{
[t2=<ADDSUB_OP>]
(t1=<INTEGER>{jjtThis.setValues((t1 == null ? "": t1.image), (t2 == null ? "": t2.image));} | LOOKAHEAD(3) Call() | Access())
}

void Exprtest() #Exprtest : {Token t1;}
{
  try{
  <LPAR>
    Lhs() t1=<RELA_OP>{jjtThis.setValues(t1.image);} Rhs()
  <RPAR>
}
catch(ParseException e){
  error_skipto(e, RPAR, "EXPRTEST");
}
}

void While() #While : {}
{
  <WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}

void If() #If : {}
{
  <IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
  try{
	  [<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>]
  }
  catch(ParseException e){
	error_skipto(e, PVIRG, "ELSE");
  }
}

void Call() #Call: {Token t1=null, t2=null;}
{
  t1=<ID> ["." t2=<ID>] <LPAR>
  {jjtThis.setValues(t1.image, (t2 == null ? "": t2.image));}
  try{
    [ArgumentList()] <RPAR>
  }
  catch(ParseException e){
    error_skipto(e, RPAR, "FUNCTION CALL ARGS");
  }
}

void ArgumentList() : {}
{
  Argument() (<VIRG> Argument())*
}

void Argument() #Argument : {Token t1;}
{
  (t1=<ID> | t1=<STRING> | t1=<INTEGER>)
  {jjtThis.setValues(t1.image);}
}

void Access() #Access : {Token t1, t2;}
{
  {t2=null;}
  t1=<ID> ("[" Index() "]" | ["." t2=<SIZE>])
  {jjtThis.setValues(t1.image, (t2 == null ? "": ".size"));}
}

void Index() #Index : {Token t1=null;}
{
  (t1=<INTEGER> | t1=<ID>) {jjtThis.setValues((t1 == null ? "" : t1.image));}
}
